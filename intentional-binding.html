<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Intentional Binding</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: #1a1a2e;
            color: #eee;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            padding: 20px;
        }

        .back-link {
            align-self: flex-start;
            color: #6366f1;
            text-decoration: none;
            font-size: 0.9rem;
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .back-link:hover {
            text-decoration: underline;
        }

        h1 {
            font-size: 1.8rem;
            margin-bottom: 10px;
            color: #fff;
        }

        .subtitle {
            color: #888;
            margin-bottom: 30px;
            text-align: center;
            max-width: 600px;
            line-height: 1.5;
        }

        .demo-container {
            background: #0d0d1a;
            border-radius: 16px;
            padding: 40px;
            margin-bottom: 20px;
            position: relative;
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        canvas {
            display: block;
        }

        .phase-indicator {
            text-align: center;
            font-size: 0.95rem;
            color: #6366f1;
            margin-bottom: 15px;
            font-weight: 500;
        }

        .trial-indicator {
            text-align: center;
            font-size: 0.85rem;
            color: #888;
            margin-bottom: 20px;
        }

        .prompt-text {
            text-align: center;
            font-size: 1.1rem;
            color: #fff;
            margin: 20px 0;
            min-height: 30px;
            font-weight: 500;
        }

        .flash-overlay {
            position: absolute;
            top: 40px;
            left: 40px;
            right: 40px;
            bottom: 40px;
            background: rgba(255, 255, 255, 0.9);
            border-radius: 8px;
            display: none;
            pointer-events: none;
        }

        .position-selector {
            display: grid;
            grid-template-columns: repeat(6, 1fr);
            gap: 10px;
            margin: 20px 0;
            max-width: 420px;
        }

        .position-btn {
            background: #374151;
            color: white;
            border: 2px solid transparent;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .position-btn:hover {
            background: #4f46e5;
            border-color: #6366f1;
        }

        .position-btn.selected {
            background: #6366f1;
            border-color: #818cf8;
        }

        .buttons {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin: 20px 0;
        }

        button {
            background: #6366f1;
            color: white;
            border: none;
            padding: 12px 30px;
            border-radius: 8px;
            font-size: 1rem;
            cursor: pointer;
            transition: background 0.2s;
        }

        button:hover {
            background: #4f46e5;
        }

        button:disabled {
            background: #374151;
            cursor: not-allowed;
            opacity: 0.6;
        }

        button.secondary {
            background: #374151;
        }

        button.secondary:hover {
            background: #4b5563;
        }

        .hidden {
            display: none !important;
        }

        .results-container {
            background: #0d0d1a;
            border-radius: 16px;
            padding: 40px;
            max-width: 700px;
            width: 100%;
        }

        .results-container h2 {
            color: #6366f1;
            margin-bottom: 20px;
            font-size: 1.4rem;
        }

        .results-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin-bottom: 30px;
        }

        .result-card {
            background: #16213e;
            border-radius: 12px;
            padding: 20px;
        }

        .result-card h3 {
            font-size: 0.95rem;
            color: #888;
            margin-bottom: 10px;
        }

        .result-card .value {
            font-size: 1.8rem;
            color: #fff;
            font-weight: 600;
        }

        .result-card .unit {
            font-size: 0.9rem;
            color: #6366f1;
            margin-left: 5px;
        }

        .binding-effect {
            background: linear-gradient(135deg, #6366f1 0%, #8b5cf6 100%);
            border-radius: 12px;
            padding: 25px;
            margin-bottom: 25px;
            text-align: center;
        }

        .binding-effect h3 {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.8);
            margin-bottom: 10px;
        }

        .binding-effect .value {
            font-size: 2.5rem;
            color: #fff;
            font-weight: 700;
        }

        .binding-effect .unit {
            font-size: 1rem;
            color: rgba(255, 255, 255, 0.8);
        }

        .interpretation {
            background: #16213e;
            border-radius: 12px;
            padding: 20px;
            color: #bbb;
            line-height: 1.7;
            font-size: 0.95rem;
        }

        .interpretation em {
            color: #6366f1;
            font-style: normal;
        }

        .instructions {
            background: #16213e;
            border-radius: 12px;
            padding: 25px;
            max-width: 600px;
            margin-top: 20px;
        }

        .instructions h2 {
            font-size: 1.1rem;
            margin-bottom: 12px;
            color: #6366f1;
        }

        .instructions p {
            color: #bbb;
            line-height: 1.6;
            margin-bottom: 10px;
            font-size: 0.95rem;
        }

        .instructions em {
            color: #6366f1;
            font-style: normal;
        }

        .spacebar-hint {
            background: rgba(99, 102, 241, 0.2);
            border: 1px solid rgba(99, 102, 241, 0.4);
            border-radius: 8px;
            padding: 15px 25px;
            margin: 15px 0;
            text-align: center;
            color: #a5b4fc;
            font-size: 0.95rem;
        }

        .phase-description {
            text-align: center;
            color: #888;
            font-size: 0.9rem;
            max-width: 500px;
            margin: 10px auto;
            line-height: 1.5;
        }
    </style>
</head>
<body>
    <a href="index.html" class="back-link">&larr; Back to experiments</a>

    <h1>Intentional Binding</h1>
    <p class="subtitle">Experience how voluntary action compresses your perception of time between cause and effect.</p>

    <div id="experiment-screen">
        <div class="phase-indicator" id="phase-indicator">Phase 1: Voluntary Action Timing</div>
        <p class="phase-description" id="phase-description">Press SPACE whenever you want. Then report when you pressed it.</p>
        <div class="trial-indicator" id="trial-indicator">Trial 1 of 5</div>

        <div class="demo-container">
            <canvas id="clock" width="400" height="400"></canvas>
            <div class="flash-overlay" id="flash-overlay"></div>
        </div>

        <p class="prompt-text" id="prompt-text">Watch the clock hand...</p>

        <div class="spacebar-hint" id="spacebar-hint">Press SPACE whenever you feel ready</div>

        <div id="response-section" class="hidden">
            <p class="prompt-text">Where was the clock hand when the event occurred?</p>
            <div class="position-selector" id="position-selector">
                <button class="position-btn" data-pos="5">5</button>
                <button class="position-btn" data-pos="10">10</button>
                <button class="position-btn" data-pos="15">15</button>
                <button class="position-btn" data-pos="20">20</button>
                <button class="position-btn" data-pos="25">25</button>
                <button class="position-btn" data-pos="30">30</button>
                <button class="position-btn" data-pos="35">35</button>
                <button class="position-btn" data-pos="40">40</button>
                <button class="position-btn" data-pos="45">45</button>
                <button class="position-btn" data-pos="50">50</button>
                <button class="position-btn" data-pos="55">55</button>
                <button class="position-btn" data-pos="60">60</button>
            </div>
            <div class="buttons">
                <button id="confirm-btn" disabled>Confirm Selection</button>
            </div>
        </div>
    </div>

    <div id="results-screen" class="results-container hidden">
        <h2>Your Results</h2>

        <div class="results-grid">
            <div class="result-card">
                <h3>Voluntary Action Timing Error</h3>
                <p><span class="value" id="vol-action-error">--</span><span class="unit">positions</span></p>
            </div>
            <div class="result-card">
                <h3>Voluntary Tone Timing Error</h3>
                <p><span class="value" id="vol-tone-error">--</span><span class="unit">positions</span></p>
            </div>
            <div class="result-card">
                <h3>Involuntary Action Timing Error</h3>
                <p><span class="value" id="invol-action-error">--</span><span class="unit">positions</span></p>
            </div>
            <div class="result-card">
                <h3>Involuntary Tone Timing Error</h3>
                <p><span class="value" id="invol-tone-error">--</span><span class="unit">positions</span></p>
            </div>
        </div>

        <div class="binding-effect">
            <h3>Intentional Binding Effect</h3>
            <p><span class="value" id="binding-effect">--</span><span class="unit">positions</span></p>
        </div>

        <div class="interpretation" id="interpretation">
            <p>Loading interpretation...</p>
        </div>

        <div class="buttons" style="margin-top: 25px;">
            <button id="restart-btn">Try Again</button>
        </div>
    </div>

    <div class="instructions">
        <h2>The Phenomenon</h2>
        <p>When you perform a <em>voluntary action</em> that causes an effect (like pressing a key that produces a sound), something strange happens: you perceive the action as occurring <em>later</em> than it actually did, and the effect as occurring <em>earlier</em>. The subjective gap between action and effect is compressed.</p>
        <p>This does not happen when the action is <em>involuntary</em> - when something just happens to you rather than being something you chose to do. The binding of cause and effect in consciousness seems to depend on your sense of agency.</p>

        <h2>The Experiment</h2>
        <p>In this Libet-style clock experiment, you will observe a rotating clock hand and report its position at the moment of different events:</p>
        <p>1. <em>Voluntary action</em>: You press SPACE and report when you pressed it</p>
        <p>2. <em>Voluntary tone</em>: You press SPACE, hear a tone 250ms later, report when you heard the tone</p>
        <p>3. <em>Involuntary action</em>: A flash appears automatically, report when you saw it</p>
        <p>4. <em>Involuntary tone</em>: A flash appears, a tone plays 250ms later, report when you heard the tone</p>

        <h2>The Philosophical Point</h2>
        <p>Intentional binding suggests that <em>agency reshapes time perception</em>. When we act voluntarily, our brain constructs a tighter temporal link between our action and its consequences. This may serve to reinforce our sense of causal control - we experience ourselves as unified agents whose intentions smoothly flow into outcomes.</p>
        <p>This raises profound questions: Is our experience of being the author of our actions a construction? Does consciousness create an illusion of seamless agency by editing the perceived timing of events?</p>
    </div>

    <script>
        // Audio context for tone generation
        let audioCtx = null;

        function initAudio() {
            if (!audioCtx) {
                audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            }
        }

        function playTone() {
            initAudio();
            const oscillator = audioCtx.createOscillator();
            const gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.frequency.value = 600;
            oscillator.type = 'sine';

            gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.1);

            oscillator.start(audioCtx.currentTime);
            oscillator.stop(audioCtx.currentTime + 0.1);
        }

        // Clock setup
        const canvas = document.getElementById('clock');
        const ctx = canvas.getContext('2d');
        const centerX = canvas.width / 2;
        const centerY = canvas.height / 2;
        const radius = 180;

        // Timing
        const rotationPeriod = 2500; // 2.5 seconds per rotation
        let startTime = Date.now();
        let clockRunning = true;
        let currentAngle = 0;

        // Experiment state
        const phases = [
            { name: 'Voluntary Action Timing', description: 'Press SPACE whenever you want. Then report when you pressed it.', type: 'vol-action' },
            { name: 'Voluntary Tone Timing', description: 'Press SPACE. A tone will play 250ms later. Report when you heard the tone.', type: 'vol-tone' },
            { name: 'Involuntary Action Timing', description: 'Wait for the flash. Then report when the flash occurred.', type: 'invol-action' },
            { name: 'Involuntary Tone Timing', description: 'Wait for the flash. A tone plays 250ms after. Report when you heard the tone.', type: 'invol-tone' }
        ];

        const trialsPerPhase = 5;
        let currentPhase = 0;
        let currentTrial = 0;
        let experimentState = 'waiting'; // waiting, responding, done
        let eventPosition = 0; // Clock position when event occurred
        let selectedPosition = null;

        // Results storage
        const results = {
            'vol-action': [],
            'vol-tone': [],
            'invol-action': [],
            'invol-tone': []
        };

        // DOM elements
        const phaseIndicator = document.getElementById('phase-indicator');
        const phaseDescription = document.getElementById('phase-description');
        const trialIndicator = document.getElementById('trial-indicator');
        const promptText = document.getElementById('prompt-text');
        const spacebarHint = document.getElementById('spacebar-hint');
        const responseSection = document.getElementById('response-section');
        const positionBtns = document.querySelectorAll('.position-btn');
        const confirmBtn = document.getElementById('confirm-btn');
        const flashOverlay = document.getElementById('flash-overlay');
        const experimentScreen = document.getElementById('experiment-screen');
        const resultsScreen = document.getElementById('results-screen');

        // Convert angle to clock position (5, 10, 15... 60)
        function angleToPosition(angle) {
            // Normalize angle to 0-360
            let normalized = ((angle % 360) + 360) % 360;
            // Convert to position (0 degrees = 15, 90 degrees = 30, etc.)
            // Clock starts at 12 o'clock (position 0/60)
            let position = Math.round((normalized / 360) * 60);
            if (position === 0) position = 60;
            // Round to nearest 5
            return Math.round(position / 5) * 5 || 5;
        }

        // Get exact position (not rounded) for error calculation
        function angleToExactPosition(angle) {
            let normalized = ((angle % 360) + 360) % 360;
            let position = (normalized / 360) * 60;
            if (position === 0) position = 60;
            return position;
        }

        // Draw the clock
        function drawClock() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Clock face background
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius + 10, 0, Math.PI * 2);
            ctx.fillStyle = '#16213e';
            ctx.fill();

            // Clock face border
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius + 10, 0, Math.PI * 2);
            ctx.strokeStyle = '#374151';
            ctx.lineWidth = 3;
            ctx.stroke();

            // Hour markers and numbers
            for (let i = 0; i < 12; i++) {
                const angle = (i * 30 - 90) * Math.PI / 180;
                const innerR = radius - 15;
                const outerR = radius - 5;
                const textR = radius - 35;

                // Marker line
                ctx.beginPath();
                ctx.moveTo(centerX + Math.cos(angle) * innerR, centerY + Math.sin(angle) * innerR);
                ctx.lineTo(centerX + Math.cos(angle) * outerR, centerY + Math.sin(angle) * outerR);
                ctx.strokeStyle = '#6366f1';
                ctx.lineWidth = 3;
                ctx.stroke();

                // Number (positions 5, 10, 15... 60)
                const position = ((i + 1) * 5);
                const displayNum = position === 60 ? 60 : position;
                ctx.font = 'bold 16px -apple-system, BlinkMacSystemFont, sans-serif';
                ctx.fillStyle = '#888';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(displayNum.toString(), centerX + Math.cos(angle) * textR, centerY + Math.sin(angle) * textR);
            }

            // Minor tick marks (between main markers)
            for (let i = 0; i < 60; i++) {
                if (i % 5 !== 0) {
                    const angle = (i * 6 - 90) * Math.PI / 180;
                    const innerR = radius - 8;
                    const outerR = radius - 5;

                    ctx.beginPath();
                    ctx.moveTo(centerX + Math.cos(angle) * innerR, centerY + Math.sin(angle) * innerR);
                    ctx.lineTo(centerX + Math.cos(angle) * outerR, centerY + Math.sin(angle) * outerR);
                    ctx.strokeStyle = '#4b5563';
                    ctx.lineWidth = 1;
                    ctx.stroke();
                }
            }

            // Center dot
            ctx.beginPath();
            ctx.arc(centerX, centerY, 8, 0, Math.PI * 2);
            ctx.fillStyle = '#374151';
            ctx.fill();

            // Clock hand
            const handLength = radius - 40;
            const handAngle = (currentAngle - 90) * Math.PI / 180;

            ctx.beginPath();
            ctx.moveTo(centerX, centerY);
            ctx.lineTo(centerX + Math.cos(handAngle) * handLength, centerY + Math.sin(handAngle) * handLength);
            ctx.strokeStyle = '#ef4444';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.stroke();

            // Hand tip
            ctx.beginPath();
            ctx.arc(centerX + Math.cos(handAngle) * handLength, centerY + Math.sin(handAngle) * handLength, 6, 0, Math.PI * 2);
            ctx.fillStyle = '#ef4444';
            ctx.fill();
        }

        // Animation loop
        function animate() {
            if (clockRunning) {
                const elapsed = Date.now() - startTime;
                currentAngle = (elapsed / rotationPeriod) * 360;
            }
            drawClock();
            requestAnimationFrame(animate);
        }

        // Update UI for current phase
        function updatePhaseUI() {
            const phase = phases[currentPhase];
            phaseIndicator.textContent = `Phase ${currentPhase + 1}: ${phase.name}`;
            phaseDescription.textContent = phase.description;
            trialIndicator.textContent = `Trial ${currentTrial + 1} of ${trialsPerPhase}`;

            if (phase.type.startsWith('vol')) {
                spacebarHint.textContent = 'Press SPACE whenever you feel ready';
                spacebarHint.classList.remove('hidden');
                promptText.textContent = 'Watch the clock hand...';
            } else {
                spacebarHint.textContent = 'Wait for the flash...';
                spacebarHint.classList.remove('hidden');
                promptText.textContent = 'Watch the clock hand...';
            }
        }

        // Start a trial
        function startTrial() {
            experimentState = 'waiting';
            selectedPosition = null;
            responseSection.classList.add('hidden');
            positionBtns.forEach(btn => btn.classList.remove('selected'));
            confirmBtn.disabled = true;
            updatePhaseUI();

            const phase = phases[currentPhase];

            if (phase.type.startsWith('invol')) {
                // Schedule automatic flash after random delay (2-5 seconds)
                const delay = 2000 + Math.random() * 3000;
                setTimeout(() => {
                    if (experimentState === 'waiting') {
                        triggerInvoluntaryEvent();
                    }
                }, delay);
            }
        }

        // Handle voluntary keypress
        function handleSpacebar() {
            if (experimentState !== 'waiting') return;

            const phase = phases[currentPhase];
            if (!phase.type.startsWith('vol')) return;

            initAudio();

            if (phase.type === 'vol-action') {
                // Record position immediately
                eventPosition = angleToExactPosition(currentAngle);
                experimentState = 'responding';
                promptText.textContent = 'Where was the clock hand when you pressed SPACE?';
                spacebarHint.classList.add('hidden');
                responseSection.classList.remove('hidden');
            } else if (phase.type === 'vol-tone') {
                // Play tone after 250ms, then ask about tone position
                spacebarHint.textContent = 'Wait for the tone...';
                setTimeout(() => {
                    eventPosition = angleToExactPosition(currentAngle);
                    playTone();
                    experimentState = 'responding';
                    promptText.textContent = 'Where was the clock hand when you heard the tone?';
                    spacebarHint.classList.add('hidden');
                    responseSection.classList.remove('hidden');
                }, 250);
            }
        }

        // Handle involuntary event
        function triggerInvoluntaryEvent() {
            const phase = phases[currentPhase];

            if (phase.type === 'invol-action') {
                // Flash immediately, record position
                eventPosition = angleToExactPosition(currentAngle);
                showFlash();
                experimentState = 'responding';
                promptText.textContent = 'Where was the clock hand when the flash occurred?';
                spacebarHint.classList.add('hidden');
                responseSection.classList.remove('hidden');
            } else if (phase.type === 'invol-tone') {
                // Flash, then tone after 250ms
                showFlash();
                spacebarHint.textContent = 'Wait for the tone...';
                setTimeout(() => {
                    eventPosition = angleToExactPosition(currentAngle);
                    playTone();
                    experimentState = 'responding';
                    promptText.textContent = 'Where was the clock hand when you heard the tone?';
                    spacebarHint.classList.add('hidden');
                    responseSection.classList.remove('hidden');
                }, 250);
            }
        }

        // Show flash
        function showFlash() {
            flashOverlay.style.display = 'block';
            setTimeout(() => {
                flashOverlay.style.display = 'none';
            }, 100);
        }

        // Handle position selection
        positionBtns.forEach(btn => {
            btn.addEventListener('click', () => {
                positionBtns.forEach(b => b.classList.remove('selected'));
                btn.classList.add('selected');
                selectedPosition = parseInt(btn.dataset.pos);
                confirmBtn.disabled = false;
            });
        });

        // Handle confirm
        confirmBtn.addEventListener('click', () => {
            if (selectedPosition === null) return;

            const phase = phases[currentPhase];
            const error = calculateError(eventPosition, selectedPosition);
            results[phase.type].push(error);

            currentTrial++;

            if (currentTrial >= trialsPerPhase) {
                currentTrial = 0;
                currentPhase++;

                if (currentPhase >= phases.length) {
                    showResults();
                    return;
                }
            }

            startTrial();
        });

        // Calculate error (accounting for circular nature of clock)
        function calculateError(actual, reported) {
            // Convert reported to continuous position
            let reportedContinuous = reported === 60 ? 0 : reported;

            // Calculate difference
            let diff = reportedContinuous - actual;

            // Handle wraparound
            if (diff > 30) diff -= 60;
            if (diff < -30) diff += 60;

            return diff;
        }

        // Calculate average
        function average(arr) {
            if (arr.length === 0) return 0;
            return arr.reduce((a, b) => a + b, 0) / arr.length;
        }

        // Show results
        function showResults() {
            experimentScreen.classList.add('hidden');
            resultsScreen.classList.remove('hidden');

            const volActionError = average(results['vol-action']);
            const volToneError = average(results['vol-tone']);
            const involActionError = average(results['invol-action']);
            const involToneError = average(results['invol-tone']);

            document.getElementById('vol-action-error').textContent = volActionError.toFixed(1);
            document.getElementById('vol-tone-error').textContent = volToneError.toFixed(1);
            document.getElementById('invol-action-error').textContent = involActionError.toFixed(1);
            document.getElementById('invol-tone-error').textContent = involToneError.toFixed(1);

            // Intentional binding effect calculation
            // Binding = (voluntary action shift toward tone) + (voluntary tone shift toward action)
            // Compared to involuntary baseline
            const voluntaryBinding = (volToneError - volActionError);
            const involuntaryBinding = (involToneError - involActionError);
            const bindingEffect = involuntaryBinding - voluntaryBinding;

            document.getElementById('binding-effect').textContent = bindingEffect.toFixed(1);

            // Generate interpretation
            const interpretation = document.getElementById('interpretation');
            let text = '';

            if (bindingEffect > 2) {
                text = `<p>Your results show a <em>positive intentional binding effect</em> of ${bindingEffect.toFixed(1)} positions. This means that when you voluntarily caused the tone, you perceived the action and its effect as closer together in time compared to when the events happened involuntarily.</p>
                <p>This compression of subjective time between voluntary action and outcome is characteristic of the intentional binding phenomenon. Your brain appears to be constructing a tighter causal link when you are the agent of the action.</p>`;
            } else if (bindingEffect < -2) {
                text = `<p>Your results show a <em>negative binding effect</em> of ${bindingEffect.toFixed(1)} positions, which is the opposite of the typical pattern. This could be due to the novelty of the task, different attention strategies between conditions, or natural variation in timing perception.</p>
                <p>The intentional binding effect can be subtle and may require many trials to emerge reliably. Consider trying again while focusing on the moment of each event.</p>`;
            } else {
                text = `<p>Your results show a <em>small binding effect</em> of ${bindingEffect.toFixed(1)} positions. While the classic intentional binding effect may not be strongly evident in your data, this is not unusual given the limited number of trials.</p>
                <p>The effect is typically more robust in laboratory settings with more trials and precise timing. What matters is experiencing how difficult it is to accurately judge the timing of events, and how our sense of agency might influence this judgment.</p>`;
            }

            text += `<p style="margin-top: 15px;">In research settings, voluntary actions are typically perceived as shifted <em>forward</em> in time (toward the effect), while effects are perceived as shifted <em>backward</em> (toward the action). This mutual attraction creates the sense that our intentions flow seamlessly into their outcomes.</p>`;

            interpretation.innerHTML = text;
        }

        // Restart experiment
        document.getElementById('restart-btn').addEventListener('click', () => {
            currentPhase = 0;
            currentTrial = 0;
            results['vol-action'] = [];
            results['vol-tone'] = [];
            results['invol-action'] = [];
            results['invol-tone'] = [];

            resultsScreen.classList.add('hidden');
            experimentScreen.classList.remove('hidden');

            startTrial();
        });

        // Keyboard handler
        document.addEventListener('keydown', (e) => {
            if (e.code === 'Space') {
                e.preventDefault();
                handleSpacebar();
            }
        });

        // Initialize
        animate();
        startTrial();
    </script>
</body>
</html>
